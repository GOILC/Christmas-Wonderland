<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title> 圣诞幻境</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050a05; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        #ui-layer {
            position: absolute; top: 20px; left: 20px; color: #d4af37;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            pointer-events: none;
        }
        .controls {
            position: absolute; bottom: 20px; left: 20px;
            background: rgba(0,0,0,0.6); padding: 15px; border-radius: 10px;
            border: 1px solid #d4af37; color: white;
        }
        #video-input { position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; 
                       border: 2px solid #c41e3a; border-radius: 8px; transform: scaleX(-1); }
        .loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #d4af37; font-size: 24px; z-index: 100;
        }
        input[type="file"] { color: #d4af37; cursor: pointer; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>Golden Christmas 2025</h1>
        <p>手势说明：握拳-聚合 | 张手-散开 | 捏合-观察照片</p>
        <div id="status">系统初始化中...</div>
    </div>

    <div class="controls">
        <label>上传照片生成照片云：</label><br>
        <input type="file" id="upload" multiple accept="image/*">
    </div>

    <video id="video-input" autoplay></video>
    <div id="canvas-container"></div>
    <div id="loading" class="loading">正在加载资源与手势模型...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 配置与常量 ---
        const PARTICLE_COUNT = 800;
        const COLORS = [0x1a472a, 0xd4af37, 0xc41e3a]; // 哑光绿, 金属金, 圣诞红
        let currentState = 'CONE'; // CONE, SPREAD, FOCUS
        let photos = [];
        let photoMeshes = [];

        // --- 初始化场景 ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050a05, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- 后期特效 (辉光) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 1.2;
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 灯光 ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xd4af37, 2);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        // --- 核心物体：实例化圣诞树 ---
        const geometries = [
            new THREE.SphereGeometry(0.1, 12, 12),
            new THREE.BoxGeometry(0.15, 0.15, 0.15),
            new THREE.CylinderGeometry(0.05, 0.05, 0.3)
        ];

        const instancedMeshes = geometries.map((geo, i) => {
            const mat = new THREE.MeshStandardMaterial({ 
                color: COLORS[i % COLORS.length], 
                metalness: 0.8, 
                roughness: 0.2 
            });
            const mesh = new THREE.InstancedMesh(geo, mat, PARTICLE_COUNT);
            scene.add(mesh);
            return mesh;
        });

        // 存储粒子的逻辑位置
        const dummy = new THREE.Object3D();
        const particles = [];
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            particles.push({
                conePos: new THREE.Vector3(),
                spreadPos: new THREE.Vector3().set(
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20
                ),
                currentPos: new THREE.Vector3(),
                rot: new THREE.Euler(Math.random() * Math.PI, Math.random() * Math.PI, 0)
            });
        }

        // 初始化圆锥体坐标 (树形状)
        particles.forEach((p, i) => {
            const height = Math.random() * 10;
            const radius = (10 - height) * 0.4;
            const angle = Math.random() * Math.PI * 2;
            p.conePos.set(
                Math.cos(angle) * radius,
                height - 5,
                Math.sin(angle) * radius
            );
        });

        // --- 媒体库：上传图片 ---
        document.getElementById('upload').addEventListener('change', (e) => {
            const files = e.target.files;
            for (let file of files) {
                const url = URL.createObjectURL(file);
                const loader = new THREE.TextureLoader();
                loader.load(url, (texture) => {
                    const geometry = new THREE.PlaneGeometry(2, 2);
                    const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10);
                    scene.add(mesh);
                    photoMeshes.push(mesh);
                });
            }
        });

        // --- MediaPipe Hands 手势识别 ---
        // 动态加载脚本以确保顺序
        async function initHands() {
            const { HandLandmarker, FilesetResolver } = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0");
            
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            const handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task` },
                runningMode: "VIDEO",
                numHands: 1
            });

            document.getElementById('loading').style.display = 'none';
            detectHands(handLandmarker);
        }

        const video = document.getElementById('video-input');
        navigator.mediaDevices.getUserMedia({ video: true }).then(stream => { video.srcObject = stream; });

        let lastVideoTime = -1;
        function detectHands(handLandmarker) {
    if (video.currentTime !== lastVideoTime && video.readyState >= 2 && video.videoWidth > 0) {
        try {
            const results = handLandmarker.detectForVideo(video, performance.now());
            if (results.landmarks && results.landmarks.length > 0) {
                processGesture(results.landmarks[0]);
            }
        } catch (error) {
            console.error("MediaPipe 检测跳过一帧:", error);
        }
        lastVideoTime = video.currentTime;
    }
    requestAnimationFrame(() => detectHands(handLandmarker));
}

        // --- 手势逻辑核心 ---
        function processGesture(landmarks) {
            // 1. 判断是否握拳 (指尖到手掌距离)
            const getDist = (a, b) => Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2);
            const isFist = getDist(landmarks[8], landmarks[5]) < 0.08 && getDist(landmarks[12], landmarks[9]) < 0.08;
            const isSpread = getDist(landmarks[8], landmarks[5]) > 0.2 && getDist(landmarks[12], landmarks[9]) > 0.2;
            const isPinch = getDist(landmarks[4], landmarks[8]) < 0.04; // 食指拇指捏合

            if (isFist) currentState = 'CONE';
            else if (isSpread) currentState = 'SPREAD';
            
            // 2. 旋转逻辑：根据手腕位置映射相机
            const wrist = landmarks[0];
            const targetX = (wrist.x - 0.5) * 20;
            const targetY = (0.5 - wrist.y) * 10;
            camera.position.x += (targetX - camera.position.x) * 0.05;
            camera.position.y += (targetY - camera.position.y) * 0.05;
            camera.lookAt(0, 0, 0);

            // 3. 捏合放大照片
            if (isPinch && photoMeshes.length > 0) {
                currentState = 'FOCUS';
                const firstPhoto = photoMeshes[0];
                firstPhoto.position.lerp(new THREE.Vector3(0, 0, 5), 0.1);
                firstPhoto.scale.lerp(new THREE.Vector3(2, 2, 2), 0.1);
            } else if (photoMeshes.length > 0) {
                photoMeshes[0].scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
            }

            document.getElementById('status').innerText = `状态: ${currentState} | 手势探测中...`;
        }

        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);

            particles.forEach((p, i) => {
                const target = currentState === 'CONE' ? p.conePos : p.spreadPos;
                p.currentPos.lerp(target, 0.05);

                dummy.position.copy(p.currentPos);
                dummy.rotation.copy(p.rot);
                
                // 简单的波动动画
                if(currentState === 'CONE') {
                    dummy.position.y += Math.sin(Date.now() * 0.001 + i) * 0.02;
                }

                dummy.updateMatrix();
                instancedMeshes.forEach(mesh => mesh.setMatrixAt(i, dummy.matrix));
            });

            instancedMeshes.forEach(mesh => mesh.instanceMatrix.needsUpdate = true);
            
            // 照片云无序漂浮
            if (currentState === 'SPREAD') {
                photoMeshes.forEach((mesh, i) => {
                    mesh.position.y += Math.sin(Date.now() * 0.0005 + i) * 0.01;
                    mesh.rotation.y += 0.01;
                });
            }

            composer.render();
        }

        initHands();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>  

