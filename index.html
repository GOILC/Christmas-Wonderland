<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>圣诞幻境</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        #ui-layer {
            position: absolute; top: 15px; left: 15px; color: #fff;
            text-shadow: 0 0 10px rgba(255,255,255,0.8); pointer-events: none; z-index: 10;
        }
        #video-input { 
            position: absolute; bottom: 10px; right: 10px; width: 100px; height: 75px; 
            border: 2px solid rgba(255,255,255,0.3); border-radius: 8px; transform: scaleX(-1);
            background: #000; z-index: 20;
        }
        .loading {
            position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
            background: #050505; color: #d4af37; z-index: 100;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h2 style="margin:0; font-size: 1.2rem; background: linear-gradient(to right, #ffcf67, #d4af37, #ff91de); -webkit-background-clip: text; color: transparent;">
            Aurora Christmas 2025
        </h2>
        <div id="status"><span id="status-text" style="font-size: 0.8rem; opacity: 0.8;">初始化梦幻引擎...</span></div>
    </div>

    <video id="video-input" autoplay muted playsinline></video>
    <div id="canvas-container"></div>
    <div id="loading" class="loading">✨ 正在召唤极光与魔法...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        let currentState = 'CONE';
        let lastVideoTime = -1;

        // --- 1. 创建动态背景 Shader ---
        const bgScene = new THREE.Scene();
        const bgCamera = new THREE.Camera();
        const bgGeometry = new THREE.PlaneGeometry(2, 2);
        const bgMaterial = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 } },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
            fragmentShader: `
                varying vec2 vUv;
                uniform float uTime;
                void main() {
                    vec2 p = vUv * 2.0 - 1.0;
                    vec3 col1 = vec3(0.02, 0.05, 0.1); // 深蓝背景
                    vec3 col2 = vec3(0.1, 0.0, 0.2);   // 深紫渐变
                    vec3 aurora = vec3(0.0, 0.8, 0.5) * (0.5 + 0.5 * sin(p.x * 2.0 + uTime * 0.5));
                    vec3 finalCol = mix(col1, col2, vUv.y) + aurora * 0.15 * (1.0 - vUv.y);
                    gl_FragColor = vec4(finalCol, 1.0);
                }
            `,
            depthWrite: false
        });
        bgScene.add(new THREE.Mesh(bgGeometry, bgMaterial));

        // --- 2. 主场景设置 ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.autoClear = false; // 必须设为 false 才能叠加背景 Shader
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.8, 0.4, 0.8);
        composer.addPass(bloomPass);

        // --- 3. 炫彩粒子系统 ---
        const PARTICLE_COUNT = 800;
        // 增加更多颜色：金、红、绿、粉、蓝
        const RAINBOW_COLORS = [0xffd700, 0xff3366, 0x33ff99, 0xff99cc, 0x00ccff];
        const geometries = [new THREE.SphereGeometry(0.12, 8, 8), new THREE.BoxGeometry(0.1, 0.1, 0.1)];
        
        const instancedMeshes = [];
        RAINBOW_COLORS.forEach((colorHex, colorIdx) => {
            geometries.forEach(geo => {
                const mat = new THREE.MeshStandardMaterial({ 
                    color: colorHex, 
                    metalness: 0.9, 
                    roughness: 0.1,
                    emissive: colorHex,
                    emissiveIntensity: 0.5
                });
                const mesh = new THREE.InstancedMesh(geo, mat, Math.floor(PARTICLE_COUNT / 10));
                scene.add(mesh);
                instancedMeshes.push(mesh);
            });
        });

        const particles = [];
        const dummy = new THREE.Object3D();
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const h = Math.random() * 10;
            const r = (10 - h) * 0.45;
            const a = Math.random() * Math.PI * 2;
            particles.push({
                conePos: new THREE.Vector3(Math.cos(a) * r, h - 5, Math.sin(a) * r),
                spreadPos: new THREE.Vector3((Math.random()-0.5)*25, (Math.random()-0.5)*20, (Math.random()-0.5)*20),
                currentPos: new THREE.Vector3(0, -15, 0),
                phase: Math.random() * Math.PI * 2
            });
        }

        // 环境星光粒子 (Background Stars)
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<1000; i++) starPos.push((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50);
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05, transparent: true, opacity: 0.8 });
        scene.add(new THREE.Points(starGeo, starMat));

        // --- 4. 逻辑与交互 ---
        async function initApp() {
            try {
                const { HandLandmarker, FilesetResolver } = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0");
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                const handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm/hand_landmarker.task` },
                    runningMode: "VIDEO", numHands: 1
                });

                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
                const video = document.getElementById('video-input');
                video.srcObject = stream;
                video.onloadeddata = () => {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('status-text').innerText = "✨ 魔法已就绪，请伸出手掌";
                    detectHands(handLandmarker, video);
                };
            } catch (e) {
                document.getElementById('loading').innerText = "魔法唤醒失败，请检查摄像头权限";
            }
        }

        function detectHands(handLandmarker, video) {
            if (video.currentTime !== lastVideoTime && video.videoWidth > 0) {
                const results = handLandmarker.detectForVideo(video, performance.now());
                if (results.landmarks && results.landmarks.length > 0) {
                    const l = results.landmarks[0];
                    const dist = Math.hypot(l[8].x - l[5].x, l[8].y - l[5].y);
                    currentState = dist < 0.1 ? 'CONE' : 'SPREAD';
                    camera.position.x += ((l[0].x - 0.5) * 20 - camera.position.x) * 0.1;
                }
                lastVideoTime = video.currentTime;
            }
            requestAnimationFrame(() => detectHands(handLandmarker, video));
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            bgMaterial.uniforms.uTime.value = time;

            let pIdx = 0;
            instancedMeshes.forEach(mesh => {
                const count = mesh.count;
                for(let i=0; i<count; i++) {
                    const p = particles[pIdx % PARTICLE_COUNT];
                    const target = currentState === 'CONE' ? p.conePos : p.spreadPos;
                    p.currentPos.lerp(target, 0.06);
                    
                    dummy.position.copy(p.currentPos);
                    // 增加旋转和轻微浮动
                    dummy.rotation.set(time + p.phase, time * 0.5, 0);
                    if(currentState === 'CONE') dummy.position.y += Math.sin(time * 2.0 + p.phase) * 0.1;
                    
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                    pIdx++;
                }
                mesh.instanceMatrix.needsUpdate = true;
            });

            camera.lookAt(0, 0, 0);
            renderer.clear();
            renderer.render(bgScene, bgCamera); // 先画极光背景
            composer.render(); // 后画 3D 场景
        }

        initApp();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
